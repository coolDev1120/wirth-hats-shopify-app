"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.request = void 0;
var tslib_1 = require("tslib");
var types_1 = require("../types");
var error_1 = require("../error");
var get_embedded_app_url_1 = require("../auth/get-embedded-app-url");
var graphql_client_1 = require("../clients/graphql/graphql_client");
var crypto_1 = require("../../runtime/crypto");
var types_2 = require("../../runtime/crypto/types");
function request(config) {
    return function (_a) {
        var _b;
        var session = _a.session, plan = _a.plan, _c = _a.isTest, isTest = _c === void 0 ? true : _c;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var billingConfig, returnUrl, GraphqlClient, client, data, _d, mutationOneTimeResponse, mutationUsageResponse, mutationRecurringResponse;
            return tslib_1.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!config.billing || !config.billing[plan]) {
                            throw new error_1.BillingError({
                                message: "Could not find plan ".concat(plan, " in billing settings"),
                                errorData: [],
                            });
                        }
                        billingConfig = config.billing[plan];
                        returnUrl = (0, get_embedded_app_url_1.buildEmbeddedAppUrl)(config)((0, crypto_1.hashString)("".concat(session.shop, "/admin"), types_2.HashFormat.Base64));
                        GraphqlClient = (0, graphql_client_1.graphqlClientClass)({ config: config });
                        client = new GraphqlClient({ session: session });
                        _d = billingConfig.interval;
                        switch (_d) {
                            case types_1.BillingInterval.OneTime: return [3 /*break*/, 1];
                            case types_1.BillingInterval.Usage: return [3 /*break*/, 3];
                        }
                        return [3 /*break*/, 5];
                    case 1: return [4 /*yield*/, requestSinglePayment({
                            billingConfig: billingConfig,
                            plan: plan,
                            client: client,
                            returnUrl: returnUrl,
                            isTest: isTest,
                        })];
                    case 2:
                        mutationOneTimeResponse = _e.sent();
                        data = mutationOneTimeResponse.data.appPurchaseOneTimeCreate;
                        return [3 /*break*/, 7];
                    case 3: return [4 /*yield*/, requestUsagePayment({
                            billingConfig: billingConfig,
                            plan: plan,
                            client: client,
                            returnUrl: returnUrl,
                            isTest: isTest,
                        })];
                    case 4:
                        mutationUsageResponse = _e.sent();
                        data = mutationUsageResponse.data.appSubscriptionCreate;
                        return [3 /*break*/, 7];
                    case 5: return [4 /*yield*/, requestRecurringPayment({
                            billingConfig: billingConfig,
                            plan: plan,
                            client: client,
                            returnUrl: returnUrl,
                            isTest: isTest,
                        })];
                    case 6:
                        mutationRecurringResponse = _e.sent();
                        data = mutationRecurringResponse.data.appSubscriptionCreate;
                        _e.label = 7;
                    case 7:
                        if ((_b = data.userErrors) === null || _b === void 0 ? void 0 : _b.length) {
                            throw new error_1.BillingError({
                                message: 'Error while billing the store',
                                errorData: data.userErrors,
                            });
                        }
                        return [2 /*return*/, data.confirmationUrl];
                }
            });
        });
    };
}
exports.request = request;
function requestRecurringPayment(_a) {
    var _b;
    var billingConfig = _a.billingConfig, plan = _a.plan, client = _a.client, returnUrl = _a.returnUrl, isTest = _a.isTest;
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var mutationResponse;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4 /*yield*/, client.query({
                        data: {
                            query: RECURRING_PURCHASE_MUTATION,
                            variables: {
                                name: plan,
                                trialDays: billingConfig.trialDays,
                                replacementBehavior: billingConfig.replacementBehavior,
                                returnUrl: returnUrl,
                                test: isTest,
                                lineItems: [
                                    {
                                        plan: {
                                            appRecurringPricingDetails: {
                                                interval: billingConfig.interval,
                                                price: {
                                                    amount: billingConfig.amount,
                                                    currencyCode: billingConfig.currencyCode,
                                                },
                                            },
                                        },
                                    },
                                ],
                            },
                        },
                    })];
                case 1:
                    mutationResponse = _c.sent();
                    if ((_b = mutationResponse.body.errors) === null || _b === void 0 ? void 0 : _b.length) {
                        throw new error_1.BillingError({
                            message: 'Error while billing the store',
                            errorData: mutationResponse.body.errors,
                        });
                    }
                    return [2 /*return*/, mutationResponse.body];
            }
        });
    });
}
function requestUsagePayment(_a) {
    var _b;
    var billingConfig = _a.billingConfig, plan = _a.plan, client = _a.client, returnUrl = _a.returnUrl, isTest = _a.isTest;
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var mutationResponse;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4 /*yield*/, client.query({
                        data: {
                            query: RECURRING_PURCHASE_MUTATION,
                            variables: {
                                name: plan,
                                returnUrl: returnUrl,
                                test: isTest,
                                lineItems: [
                                    {
                                        plan: {
                                            appUsagePricingDetails: {
                                                terms: billingConfig.usageTerms,
                                                cappedAmount: {
                                                    amount: billingConfig.amount,
                                                    currencyCode: billingConfig.currencyCode,
                                                },
                                            },
                                        },
                                    },
                                ],
                            },
                        },
                    })];
                case 1:
                    mutationResponse = _c.sent();
                    if ((_b = mutationResponse.body.errors) === null || _b === void 0 ? void 0 : _b.length) {
                        throw new error_1.BillingError({
                            message: "Error while billing the store:: ".concat(mutationResponse.body.errors),
                            errorData: mutationResponse.body.errors,
                        });
                    }
                    return [2 /*return*/, mutationResponse.body];
            }
        });
    });
}
function requestSinglePayment(_a) {
    var _b;
    var billingConfig = _a.billingConfig, plan = _a.plan, client = _a.client, returnUrl = _a.returnUrl, isTest = _a.isTest;
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var mutationResponse;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4 /*yield*/, client.query({
                        data: {
                            query: ONE_TIME_PURCHASE_MUTATION,
                            variables: {
                                name: plan,
                                returnUrl: returnUrl,
                                test: isTest,
                                price: {
                                    amount: billingConfig.amount,
                                    currencyCode: billingConfig.currencyCode,
                                },
                            },
                        },
                    })];
                case 1:
                    mutationResponse = _c.sent();
                    if ((_b = mutationResponse.body.errors) === null || _b === void 0 ? void 0 : _b.length) {
                        throw new error_1.BillingError({
                            message: 'Error while billing the store',
                            errorData: mutationResponse.body.errors,
                        });
                    }
                    return [2 /*return*/, mutationResponse.body];
            }
        });
    });
}
var RECURRING_PURCHASE_MUTATION = "\n  mutation test(\n    $name: String!\n    $lineItems: [AppSubscriptionLineItemInput!]!\n    $returnUrl: URL!\n    $test: Boolean\n    $trialDays: Int\n    $replacementBehavior: AppSubscriptionReplacementBehavior\n  ) {\n    appSubscriptionCreate(\n      name: $name\n      lineItems: $lineItems\n      returnUrl: $returnUrl\n      test: $test\n      trialDays: $trialDays\n      replacementBehavior: $replacementBehavior\n    ) {\n      confirmationUrl\n      userErrors {\n        field\n        message\n      }\n    }\n  }\n";
var ONE_TIME_PURCHASE_MUTATION = "\n  mutation test(\n    $name: String!\n    $price: MoneyInput!\n    $returnUrl: URL!\n    $test: Boolean\n  ) {\n    appPurchaseOneTimeCreate(\n      name: $name\n      price: $price\n      returnUrl: $returnUrl\n      test: $test\n    ) {\n      confirmationUrl\n      userErrors {\n        field\n        message\n      }\n    }\n  }\n";
//# sourceMappingURL=request.js.map