"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.httpClientClass = exports.HttpClient = void 0;
var tslib_1 = require("tslib");
var network_1 = require("@shopify/network");
var ShopifyErrors = tslib_1.__importStar(require("../../error"));
var types_1 = require("../../types");
var version_1 = require("../../version");
var processed_query_1 = tslib_1.__importDefault(require("../../utils/processed-query"));
var crypto_1 = require("../../../runtime/crypto");
var types_2 = require("../../../runtime/crypto/types");
var http_1 = require("../../../runtime/http");
var platform_1 = require("../../../runtime/platform");
var logger_1 = require("../../logger");
var types_3 = require("./types");
var HttpClient = /** @class */ (function () {
    function HttpClient(params) {
        this.loggedDeprecations = {};
        this.domain = params.domain;
    }
    /**
     * Performs a GET request on the given path.
     */
    HttpClient.prototype.get = function (params) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.request(tslib_1.__assign({ method: network_1.Method.Get }, params))];
            });
        });
    };
    /**
     * Performs a POST request on the given path.
     */
    HttpClient.prototype.post = function (params) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.request(tslib_1.__assign({ method: network_1.Method.Post }, params))];
            });
        });
    };
    /**
     * Performs a PUT request on the given path.
     */
    HttpClient.prototype.put = function (params) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.request(tslib_1.__assign({ method: network_1.Method.Put }, params))];
            });
        });
    };
    /**
     * Performs a DELETE request on the given path.
     */
    HttpClient.prototype.delete = function (params) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.request(tslib_1.__assign({ method: network_1.Method.Delete }, params))];
            });
        });
    };
    HttpClient.prototype.request = function (params) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            function sleep(waitTime) {
                return tslib_1.__awaiter(this, void 0, void 0, function () {
                    return tslib_1.__generator(this, function (_a) {
                        return [2 /*return*/, new Promise(function (resolve) { return setTimeout(resolve, waitTime); })];
                    });
                });
            }
            var maxTries, userAgent, headers, body, type, data, url, request, message, tries, error_1, waitTime;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        maxTries = params.tries ? params.tries : 1;
                        if (maxTries <= 0) {
                            throw new ShopifyErrors.HttpRequestError("Number of tries must be >= 0, got ".concat(maxTries));
                        }
                        userAgent = "".concat(types_1.LIBRARY_NAME, " v").concat(version_1.SHOPIFY_API_LIBRARY_VERSION, " | ").concat((0, platform_1.abstractRuntimeString)());
                        if (this.httpClass().config.userAgentPrefix) {
                            userAgent = "".concat(this.httpClass().config.userAgentPrefix, " | ").concat(userAgent);
                        }
                        if (params.extraHeaders) {
                            if (params.extraHeaders['user-agent']) {
                                userAgent = "".concat(params.extraHeaders['user-agent'], " | ").concat(userAgent);
                                delete params.extraHeaders['user-agent'];
                            }
                            else if (params.extraHeaders['User-Agent']) {
                                userAgent = "".concat(params.extraHeaders['User-Agent'], " | ").concat(userAgent);
                            }
                        }
                        headers = tslib_1.__assign(tslib_1.__assign({}, params.extraHeaders), { 'User-Agent': userAgent });
                        if (params.method === network_1.Method.Post || params.method === network_1.Method.Put) {
                            type = (_a = params.type) !== null && _a !== void 0 ? _a : types_3.DataType.JSON;
                            data = params.data;
                            if (data) {
                                switch (type) {
                                    case types_3.DataType.JSON:
                                        body = typeof data === 'string' ? data : JSON.stringify(data);
                                        break;
                                    case types_3.DataType.URLEncoded:
                                        body =
                                            typeof data === 'string'
                                                ? data
                                                : new URLSearchParams(data).toString();
                                        break;
                                    case types_3.DataType.GraphQL:
                                        body = data;
                                        break;
                                }
                                headers = tslib_1.__assign(tslib_1.__assign({}, headers), { 'Content-Type': type, 'Content-Length': new TextEncoder().encode(body).length });
                            }
                        }
                        url = "".concat(this.httpClass().scheme, "://").concat(this.domain).concat(this.getRequestPath(params.path)).concat(processed_query_1.default.stringify(params.query));
                        request = {
                            method: params.method,
                            url: url,
                            headers: (0, http_1.canonicalizeHeaders)(headers),
                            body: body,
                        };
                        if (this.httpClass().config.logger.httpRequests) {
                            message = [
                                'Making HTTP request',
                                "".concat(request.method, " ").concat(request.url),
                                "Headers: ".concat(JSON.stringify(headers)),
                            ];
                            if (body) {
                                message.push("Body: ".concat(JSON.stringify(body).replace(/\n/g, '\\n  ')));
                            }
                            (0, logger_1.logger)(this.httpClass().config).debug(message.join('  -  '));
                        }
                        tries = 0;
                        _b.label = 1;
                    case 1:
                        if (!(tries < maxTries)) return [3 /*break*/, 9];
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 4, , 8]);
                        return [4 /*yield*/, this.doRequest(request)];
                    case 3: return [2 /*return*/, _b.sent()];
                    case 4:
                        error_1 = _b.sent();
                        tries++;
                        if (!(error_1 instanceof ShopifyErrors.HttpRetriableError)) return [3 /*break*/, 7];
                        if (!(tries < maxTries)) return [3 /*break*/, 6];
                        waitTime = this.httpClass().RETRY_WAIT_TIME;
                        if (error_1 instanceof ShopifyErrors.HttpThrottlingError &&
                            error_1.response.retryAfter) {
                            waitTime = error_1.response.retryAfter * 1000;
                        }
                        return [4 /*yield*/, sleep(waitTime)];
                    case 5:
                        _b.sent();
                        return [3 /*break*/, 1];
                    case 6:
                        // We're set to multiple tries but ran out
                        if (maxTries > 1) {
                            throw new ShopifyErrors.HttpMaxRetriesError("Exceeded maximum retry count of ".concat(maxTries, ". Last message: ").concat(error_1.message));
                        }
                        _b.label = 7;
                    case 7: 
                    // We're not retrying or the error is not retriable, rethrow
                    throw error_1;
                    case 8: return [3 /*break*/, 1];
                    case 9: 
                    // We're never supposed to come this far, this is here only for the benefit of Typescript
                    /* istanbul ignore next */
                    throw new ShopifyErrors.ShopifyError("Unexpected flow, reached maximum HTTP tries but did not throw an error");
                }
            });
        });
    };
    HttpClient.prototype.getRequestPath = function (path) {
        return "/".concat(path.replace(/^\//, ''));
    };
    HttpClient.prototype.httpClass = function () {
        return this.constructor;
    };
    HttpClient.prototype.throwFailedRequest = function (body, response) {
        var errorMessages = [];
        if (body.errors) {
            errorMessages.push(JSON.stringify(body.errors, null, 2));
        }
        var xRequestId = (0, http_1.getHeader)(response.headers, 'x-request-id');
        if (xRequestId) {
            errorMessages.push("If you report this error, please include this id: ".concat(xRequestId));
        }
        var errorMessage = errorMessages.length
            ? ":\n".concat(errorMessages.join('\n'))
            : '';
        var headers = response.headers ? response.headers : {};
        var code = response.statusCode;
        var statusText = response.statusText;
        switch (true) {
            case response.statusCode === network_1.StatusCode.TooManyRequests: {
                var retryAfter = (0, http_1.getHeader)(response.headers, 'Retry-After');
                throw new ShopifyErrors.HttpThrottlingError({
                    message: "Shopify is throttling requests".concat(errorMessage),
                    code: code,
                    statusText: statusText,
                    body: body,
                    headers: headers,
                    retryAfter: retryAfter ? parseFloat(retryAfter) : undefined,
                });
            }
            case response.statusCode >= network_1.StatusCode.InternalServerError:
                throw new ShopifyErrors.HttpInternalError({
                    message: "Shopify internal error".concat(errorMessage),
                    code: code,
                    statusText: statusText,
                    body: body,
                    headers: headers,
                });
            default:
                throw new ShopifyErrors.HttpResponseError({
                    message: "Received an error response (".concat(response.statusCode, " ").concat(response.statusText, ") from Shopify").concat(errorMessage),
                    code: code,
                    statusText: statusText,
                    body: body,
                    headers: headers,
                });
        }
    };
    HttpClient.prototype.doRequest = function (request) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var log, response, body, deprecationReason, deprecation, depHash, stack, message;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        log = (0, logger_1.logger)(this.httpClass().config);
                        return [4 /*yield*/, (0, http_1.abstractFetch)(request)];
                    case 1:
                        response = _b.sent();
                        if (this.httpClass().config.logger.httpRequests) {
                            log.debug("Completed HTTP request, received ".concat(response.statusCode, " ").concat(response.statusText));
                        }
                        body = {};
                        if (response.body) {
                            try {
                                body = JSON.parse(response.body);
                            }
                            catch (error) {
                                body = response.body;
                            }
                        }
                        if (!(0, http_1.isOK)(response)) {
                            this.throwFailedRequest(body, response);
                        }
                        deprecationReason = (0, http_1.getHeader)(response.headers, 'X-Shopify-API-Deprecated-Reason');
                        if (!deprecationReason) return [3 /*break*/, 4];
                        deprecation = {
                            message: deprecationReason,
                            path: request.url,
                        };
                        if (request.body) {
                            // This can only be a string, since we're always converting the body before calling this method
                            deprecation.body = "".concat(request.body.substring(0, 100), "...");
                        }
                        return [4 /*yield*/, (0, crypto_1.createSHA256HMAC)(this.httpClass().config.apiSecretKey, JSON.stringify(deprecation), types_2.HashFormat.Hex)];
                    case 2:
                        depHash = _b.sent();
                        if (!(!Object.keys(this.loggedDeprecations).includes(depHash) ||
                            Date.now() - this.loggedDeprecations[depHash] >=
                                HttpClient.DEPRECATION_ALERT_DELAY)) return [3 /*break*/, 4];
                        this.loggedDeprecations[depHash] = Date.now();
                        stack = new Error().stack;
                        message = "API Deprecation Notice ".concat(new Date().toLocaleString(), " : ").concat(JSON.stringify(deprecation), "  -  Stack Trace: ").concat(stack);
                        return [4 /*yield*/, log.warning(message)];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4: return [2 /*return*/, {
                            body: body,
                            headers: (_a = response.headers) !== null && _a !== void 0 ? _a : {},
                        }];
                }
            });
        });
    };
    // 1 second
    HttpClient.RETRY_WAIT_TIME = 1000;
    // 5 minutes
    HttpClient.DEPRECATION_ALERT_DELAY = 300000;
    return HttpClient;
}());
exports.HttpClient = HttpClient;
function httpClientClass(config, scheme) {
    if (scheme === void 0) { scheme = 'https'; }
    var NewHttpClient = /** @class */ (function (_super) {
        tslib_1.__extends(NewHttpClient, _super);
        function NewHttpClient() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NewHttpClient.config = config;
        NewHttpClient.scheme = scheme;
        return NewHttpClient;
    }(HttpClient));
    Reflect.defineProperty(NewHttpClient, 'name', {
        value: 'HttpClient',
    });
    return NewHttpClient;
}
exports.httpClientClass = httpClientClass;
//# sourceMappingURL=http_client.js.map