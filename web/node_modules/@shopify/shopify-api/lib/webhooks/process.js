"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.process = void 0;
var tslib_1 = require("tslib");
var network_1 = require("@shopify/network");
var http_1 = require("../../runtime/http");
var crypto_1 = require("../../runtime/crypto");
var types_1 = require("../../runtime/crypto/types");
var types_2 = require("../types");
var safe_compare_1 = require("../auth/oauth/safe-compare");
var ShopifyErrors = tslib_1.__importStar(require("../error"));
var logger_1 = require("../logger");
var types_3 = require("./types");
var registry_1 = require("./registry");
function process(config, webhookRegistry) {
    return function process(_a) {
        var rawBody = _a.rawBody, adapterArgs = tslib_1.__rest(_a, ["rawBody"]);
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var request, response, webhookCheck, webhookOk, apiVersion, domain, hmac, topic, webhookId, errorMessage, loggingContext, log, graphqlTopic, handlers, found, handlers_1, handlers_1_1, handler, error_1, e_1_1, returnResponse;
            var e_1, _b;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, (0, http_1.abstractConvertRequest)(adapterArgs)];
                    case 1:
                        request = _c.sent();
                        response = {
                            statusCode: network_1.StatusCode.Ok,
                            statusText: statusTextLookup[network_1.StatusCode.Ok],
                            headers: {},
                        };
                        webhookCheck = checkWebhookRequest(rawBody, request.headers);
                        webhookOk = webhookCheck.webhookOk, apiVersion = webhookCheck.apiVersion, domain = webhookCheck.domain, hmac = webhookCheck.hmac, topic = webhookCheck.topic, webhookId = webhookCheck.webhookId;
                        errorMessage = webhookCheck.errorMessage;
                        loggingContext = { apiVersion: apiVersion, domain: domain, topic: topic, webhookId: webhookId };
                        log = (0, logger_1.logger)(config);
                        log.info('Processing webhook request', loggingContext);
                        if (!webhookOk) return [3 /*break*/, 15];
                        log.debug('Webhook request is well formed', loggingContext);
                        return [4 /*yield*/, validateOkWebhook(config.apiSecretKey, rawBody, hmac)];
                    case 2:
                        if (!_c.sent()) return [3 /*break*/, 13];
                        log.debug('Webhook request is valid', loggingContext);
                        graphqlTopic = (0, registry_1.topicForStorage)(topic);
                        handlers = webhookRegistry[graphqlTopic] || [];
                        found = false;
                        _c.label = 3;
                    case 3:
                        _c.trys.push([3, 10, 11, 12]);
                        handlers_1 = tslib_1.__values(handlers), handlers_1_1 = handlers_1.next();
                        _c.label = 4;
                    case 4:
                        if (!!handlers_1_1.done) return [3 /*break*/, 9];
                        handler = handlers_1_1.value;
                        if (handler.deliveryMethod !== types_3.DeliveryMethod.Http) {
                            return [3 /*break*/, 8];
                        }
                        found = true;
                        log.debug('Found HTTP handler, triggering it', loggingContext);
                        _c.label = 5;
                    case 5:
                        _c.trys.push([5, 7, , 8]);
                        return [4 /*yield*/, handler.callback(graphqlTopic, domain, rawBody, webhookId, apiVersion)];
                    case 6:
                        _c.sent();
                        response.statusCode = network_1.StatusCode.Ok;
                        return [3 /*break*/, 8];
                    case 7:
                        error_1 = _c.sent();
                        response.statusCode = network_1.StatusCode.InternalServerError;
                        errorMessage = error_1.message;
                        return [3 /*break*/, 8];
                    case 8:
                        handlers_1_1 = handlers_1.next();
                        return [3 /*break*/, 4];
                    case 9: return [3 /*break*/, 12];
                    case 10:
                        e_1_1 = _c.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 12];
                    case 11:
                        try {
                            if (handlers_1_1 && !handlers_1_1.done && (_b = handlers_1.return)) _b.call(handlers_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 12:
                        if (!found) {
                            log.debug('No HTTP handlers found', loggingContext);
                            response.statusCode = network_1.StatusCode.NotFound;
                            errorMessage = "No HTTP webhooks registered for topic ".concat(graphqlTopic);
                        }
                        return [3 /*break*/, 14];
                    case 13:
                        log.debug('Webhook validation failed', loggingContext);
                        response.statusCode = network_1.StatusCode.Unauthorized;
                        errorMessage = "Could not validate request for topic ".concat(topic);
                        _c.label = 14;
                    case 14: return [3 /*break*/, 16];
                    case 15:
                        log.debug('Webhook request is malformed', loggingContext);
                        response.statusCode = network_1.StatusCode.BadRequest;
                        _c.label = 16;
                    case 16:
                        response.statusText = statusTextLookup[response.statusCode];
                        return [4 /*yield*/, (0, http_1.abstractConvertResponse)(response, adapterArgs)];
                    case 17:
                        returnResponse = _c.sent();
                        if (!(0, http_1.isOK)(response)) {
                            throw new ShopifyErrors.InvalidWebhookError({
                                message: errorMessage,
                                response: returnResponse,
                            });
                        }
                        return [2 /*return*/, Promise.resolve(returnResponse)];
                }
            });
        });
    };
}
exports.process = process;
var statusTextLookup = (_a = {},
    _a[network_1.StatusCode.Ok] = 'OK',
    _a[network_1.StatusCode.BadRequest] = 'Bad Request',
    _a[network_1.StatusCode.Unauthorized] = 'Unauthorized',
    _a[network_1.StatusCode.NotFound] = 'Not Found',
    _a[network_1.StatusCode.InternalServerError] = 'Internal Server Error',
    _a);
var headerProperties = [
    {
        property: 'apiVersion',
        headerName: types_2.ShopifyHeader.ApiVersion,
    },
    {
        property: 'domain',
        headerName: types_2.ShopifyHeader.Domain,
    },
    {
        property: 'hmac',
        headerName: types_2.ShopifyHeader.Hmac,
    },
    {
        property: 'topic',
        headerName: types_2.ShopifyHeader.Topic,
    },
    {
        property: 'webhookId',
        headerName: types_2.ShopifyHeader.WebhookId,
    },
];
function checkWebhookRequest(rawBody, headers) {
    var retVal = {
        webhookOk: true,
        errorMessage: '',
        apiVersion: '',
        domain: '',
        hmac: '',
        topic: '',
        webhookId: '',
    };
    if (rawBody.length) {
        var missingHeaders_1 = [];
        var headerValues_1 = {};
        headerProperties.forEach(function (_a) {
            var property = _a.property, headerName = _a.headerName;
            var headerValue = (0, http_1.getHeader)(headers, headerName);
            if (headerValue) {
                headerValues_1[property] = headerValue;
            }
            else {
                missingHeaders_1.push(headerName);
            }
        });
        if (missingHeaders_1.length) {
            retVal.webhookOk = false;
            retVal.errorMessage = "Missing one or more of the required HTTP headers to process webhooks: [".concat(missingHeaders_1.join(', '), "]");
        }
        else {
            retVal = tslib_1.__assign(tslib_1.__assign({}, retVal), headerValues_1);
        }
    }
    else {
        retVal.webhookOk = false;
        retVal.errorMessage = 'No body was received when processing webhook';
    }
    return retVal;
}
function validateOkWebhook(secret, rawBody, hmac) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var generatedHash;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, crypto_1.createSHA256HMAC)(secret, rawBody, types_1.HashFormat.Base64)];
                case 1:
                    generatedHash = _a.sent();
                    return [2 /*return*/, (0, safe_compare_1.safeCompare)(generatedHash, hmac)];
            }
        });
    });
}
//# sourceMappingURL=process.js.map