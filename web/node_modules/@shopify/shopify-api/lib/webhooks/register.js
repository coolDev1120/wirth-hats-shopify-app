"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TEMPLATE_MUTATION = exports.TEMPLATE_GET_HANDLERS = exports.register = void 0;
var tslib_1 = require("tslib");
var graphql_client_1 = require("../clients/graphql/graphql_client");
var error_1 = require("../error");
var logger_1 = require("../logger");
var types_1 = require("../types");
var registry_1 = require("./registry");
var query_template_1 = require("./query-template");
var types_2 = require("./types");
function register(config, webhookRegistry) {
    return function register(_a) {
        var session = _a.session;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var log, registerReturn, existingHandlers, _b, _c, _i, topic, _d, _e, _f, _g, _h, topic, GraphqlClient_1, client, _j, _k;
            return tslib_1.__generator(this, function (_l) {
                switch (_l.label) {
                    case 0:
                        log = (0, logger_1.logger)(config);
                        log.info('Registering webhooks', { shop: session.shop });
                        registerReturn = Object.keys(webhookRegistry).reduce(function (acc, topic) {
                            acc[topic] = [];
                            return acc;
                        }, {});
                        return [4 /*yield*/, getExistingHandlers(config, session)];
                    case 1:
                        existingHandlers = _l.sent();
                        log.debug("Existing topics: [".concat(Object.keys(existingHandlers).join(', '), "]"), { shop: session.shop });
                        _b = [];
                        for (_c in webhookRegistry)
                            _b.push(_c);
                        _i = 0;
                        _l.label = 2;
                    case 2:
                        if (!(_i < _b.length)) return [3 /*break*/, 5];
                        topic = _b[_i];
                        if (!Object.prototype.hasOwnProperty.call(webhookRegistry, topic)) {
                            return [3 /*break*/, 4];
                        }
                        if (types_1.gdprTopics.includes(topic)) {
                            return [3 /*break*/, 4];
                        }
                        _d = registerReturn;
                        _e = topic;
                        return [4 /*yield*/, registerTopic({
                                config: config,
                                session: session,
                                topic: topic,
                                existingHandlers: existingHandlers[topic] || [],
                                handlers: (0, registry_1.getHandlers)(webhookRegistry)(topic),
                            })];
                    case 3:
                        _d[_e] = _l.sent();
                        // Remove this topic from the list of existing handlers so we have a list of leftovers
                        delete existingHandlers[topic];
                        _l.label = 4;
                    case 4:
                        _i++;
                        return [3 /*break*/, 2];
                    case 5:
                        _f = [];
                        for (_g in existingHandlers)
                            _f.push(_g);
                        _h = 0;
                        _l.label = 6;
                    case 6:
                        if (!(_h < _f.length)) return [3 /*break*/, 9];
                        topic = _f[_h];
                        if (!Object.prototype.hasOwnProperty.call(existingHandlers, topic)) {
                            return [3 /*break*/, 8];
                        }
                        GraphqlClient_1 = (0, graphql_client_1.graphqlClientClass)({ config: config });
                        client = new GraphqlClient_1({ session: session });
                        _j = registerReturn;
                        _k = topic;
                        return [4 /*yield*/, runMutations({
                                config: config,
                                client: client,
                                topic: topic,
                                handlers: existingHandlers[topic],
                                operation: types_2.WebhookOperation.Delete,
                            })];
                    case 7:
                        _j[_k] = _l.sent();
                        _l.label = 8;
                    case 8:
                        _h++;
                        return [3 /*break*/, 6];
                    case 9: return [2 /*return*/, registerReturn];
                }
            });
        });
    };
}
exports.register = register;
function getExistingHandlers(config, session) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var GraphqlClient, client, existingHandlers, hasNextPage, endCursor, query, response;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    GraphqlClient = (0, graphql_client_1.graphqlClientClass)({ config: config });
                    client = new GraphqlClient({ session: session });
                    existingHandlers = {};
                    endCursor = null;
                    _a.label = 1;
                case 1:
                    query = buildCheckQuery(endCursor);
                    return [4 /*yield*/, client.query({
                            data: query,
                        })];
                case 2:
                    response = _a.sent();
                    response.body.data.webhookSubscriptions.edges.forEach(function (edge) {
                        var handler = buildHandlerFromNode(edge);
                        if (!existingHandlers[edge.node.topic]) {
                            existingHandlers[edge.node.topic] = [];
                        }
                        existingHandlers[edge.node.topic].push(handler);
                    });
                    endCursor = response.body.data.webhookSubscriptions.pageInfo.endCursor;
                    hasNextPage = response.body.data.webhookSubscriptions.pageInfo.hasNextPage;
                    _a.label = 3;
                case 3:
                    if (hasNextPage) return [3 /*break*/, 1];
                    _a.label = 4;
                case 4: return [2 /*return*/, existingHandlers];
            }
        });
    });
}
function buildCheckQuery(endCursor) {
    return (0, query_template_1.queryTemplate)(exports.TEMPLATE_GET_HANDLERS, {
        END_CURSOR: JSON.stringify(endCursor),
    });
}
function buildHandlerFromNode(edge) {
    var _this = this;
    var _a, _b, _c;
    var endpoint = edge.node.endpoint;
    var handler;
    switch (endpoint.__typename) {
        case 'WebhookHttpEndpoint':
            handler = {
                deliveryMethod: types_2.DeliveryMethod.Http,
                privateMetafieldNamespaces: edge.node.privateMetafieldNamespaces,
                callbackUrl: endpoint.callbackUrl,
                // This is a dummy for now because we don't really care about it
                callback: function () { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                    return [2 /*return*/];
                }); }); },
            };
            // This field only applies to HTTP webhooks
            (_a = handler.privateMetafieldNamespaces) === null || _a === void 0 ? void 0 : _a.sort();
            break;
        case 'WebhookEventBridgeEndpoint':
            handler = {
                deliveryMethod: types_2.DeliveryMethod.EventBridge,
                arn: endpoint.arn,
            };
            break;
        case 'WebhookPubSubEndpoint':
            handler = {
                deliveryMethod: types_2.DeliveryMethod.PubSub,
                pubSubProject: endpoint.pubSubProject,
                pubSubTopic: endpoint.pubSubTopic,
            };
            break;
    }
    // Set common fields
    handler.id = edge.node.id;
    handler.includeFields = edge.node.includeFields;
    handler.metafieldNamespaces = edge.node.metafieldNamespaces;
    // Sort the array fields to make them cheaper to compare later on
    (_b = handler.includeFields) === null || _b === void 0 ? void 0 : _b.sort();
    (_c = handler.metafieldNamespaces) === null || _c === void 0 ? void 0 : _c.sort();
    return handler;
}
function registerTopic(_a) {
    var config = _a.config, session = _a.session, topic = _a.topic, existingHandlers = _a.existingHandlers, handlers = _a.handlers;
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var registerResults, _b, toCreate, toUpdate, toDelete, GraphqlClient, client, operation, _c, _d, _e, _f, _g, _h;
        return tslib_1.__generator(this, function (_j) {
            switch (_j.label) {
                case 0:
                    registerResults = [];
                    _b = categorizeHandlers(config, existingHandlers, handlers), toCreate = _b.toCreate, toUpdate = _b.toUpdate, toDelete = _b.toDelete;
                    GraphqlClient = (0, graphql_client_1.graphqlClientClass)({ config: config });
                    client = new GraphqlClient({ session: session });
                    operation = types_2.WebhookOperation.Create;
                    _d = (_c = registerResults).concat;
                    return [4 /*yield*/, runMutations({ config: config, client: client, topic: topic, operation: operation, handlers: toCreate })];
                case 1:
                    registerResults = _d.apply(_c, [_j.sent()]);
                    operation = types_2.WebhookOperation.Update;
                    _f = (_e = registerResults).concat;
                    return [4 /*yield*/, runMutations({ config: config, client: client, topic: topic, operation: operation, handlers: toUpdate })];
                case 2:
                    registerResults = _f.apply(_e, [_j.sent()]);
                    operation = types_2.WebhookOperation.Delete;
                    _h = (_g = registerResults).concat;
                    return [4 /*yield*/, runMutations({ config: config, client: client, topic: topic, operation: operation, handlers: toDelete })];
                case 3:
                    registerResults = _h.apply(_g, [_j.sent()]);
                    return [2 /*return*/, registerResults];
            }
        });
    });
}
function categorizeHandlers(config, existingHandlers, handlers) {
    var handlersByKey = handlers.reduce(function (acc, value) {
        acc[(0, registry_1.handlerIdentifier)(config, value)] = value;
        return acc;
    }, {});
    var existingHandlersByKey = existingHandlers.reduce(function (acc, value) {
        acc[(0, registry_1.handlerIdentifier)(config, value)] = value;
        return acc;
    }, {});
    var toCreate = tslib_1.__assign({}, handlersByKey);
    var toUpdate = {};
    var toDelete = {};
    for (var existingKey in existingHandlersByKey) {
        if (!Object.prototype.hasOwnProperty.call(existingHandlersByKey, existingKey)) {
            continue;
        }
        var existingHandler = existingHandlersByKey[existingKey];
        var handler = handlersByKey[existingKey];
        if (existingKey in handlersByKey) {
            delete toCreate[existingKey];
            if (!areHandlerFieldsEqual(existingHandler, handler)) {
                toUpdate[existingKey] = handler;
                toUpdate[existingKey].id = existingHandler.id;
            }
        }
        else {
            toDelete[existingKey] = existingHandler;
        }
    }
    return {
        toCreate: Object.values(toCreate),
        toUpdate: Object.values(toUpdate),
        toDelete: Object.values(toDelete),
    };
}
function areHandlerFieldsEqual(arr1, arr2) {
    var includeFieldsEqual = arraysEqual(arr1.includeFields || [], arr2.includeFields || []);
    var metafieldNamespacesEqual = arraysEqual(arr1.metafieldNamespaces || [], arr2.metafieldNamespaces || []);
    var privateMetafieldNamespacesEqual = arr1.deliveryMethod !== types_2.DeliveryMethod.Http ||
        arr2.deliveryMethod !== types_2.DeliveryMethod.Http ||
        arraysEqual(arr1.privateMetafieldNamespaces || [], arr2.privateMetafieldNamespaces || []);
    return (includeFieldsEqual &&
        metafieldNamespacesEqual &&
        privateMetafieldNamespacesEqual);
}
function arraysEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) {
        return false;
    }
    for (var i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }
    return true;
}
function runMutations(_a) {
    var config = _a.config, client = _a.client, topic = _a.topic, handlers = _a.handlers, operation = _a.operation;
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var registerResults, handlers_1, handlers_1_1, handler, _b, _c, e_1_1;
        var e_1, _d;
        return tslib_1.__generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    registerResults = [];
                    _e.label = 1;
                case 1:
                    _e.trys.push([1, 6, 7, 8]);
                    handlers_1 = tslib_1.__values(handlers), handlers_1_1 = handlers_1.next();
                    _e.label = 2;
                case 2:
                    if (!!handlers_1_1.done) return [3 /*break*/, 5];
                    handler = handlers_1_1.value;
                    _c = (_b = registerResults).push;
                    return [4 /*yield*/, runMutation({ config: config, client: client, topic: topic, handler: handler, operation: operation })];
                case 3:
                    _c.apply(_b, [_e.sent()]);
                    _e.label = 4;
                case 4:
                    handlers_1_1 = handlers_1.next();
                    return [3 /*break*/, 2];
                case 5: return [3 /*break*/, 8];
                case 6:
                    e_1_1 = _e.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 8];
                case 7:
                    try {
                        if (handlers_1_1 && !handlers_1_1.done && (_d = handlers_1.return)) _d.call(handlers_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 8: return [2 /*return*/, registerResults];
            }
        });
    });
}
function runMutation(_a) {
    var config = _a.config, client = _a.client, topic = _a.topic, handler = _a.handler, operation = _a.operation;
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var registerResult, query, result, error_2;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    (0, logger_1.logger)(config).debug("Running webhook mutation", { topic: topic, operation: operation });
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 3, , 4]);
                    query = buildMutation(config, topic, handler, operation);
                    return [4 /*yield*/, client.query({ data: query })];
                case 2:
                    result = _b.sent();
                    registerResult = {
                        deliveryMethod: handler.deliveryMethod,
                        success: isSuccess(result.body, handler, operation),
                        result: result.body,
                    };
                    return [3 /*break*/, 4];
                case 3:
                    error_2 = _b.sent();
                    if (error_2 instanceof error_1.InvalidDeliveryMethodError) {
                        registerResult = {
                            deliveryMethod: handler.deliveryMethod,
                            success: false,
                            result: { message: error_2.message },
                        };
                    }
                    else {
                        throw error_2;
                    }
                    return [3 /*break*/, 4];
                case 4: return [2 /*return*/, registerResult];
            }
        });
    });
}
function buildMutation(config, topic, handler, operation) {
    var params = {};
    var identifier;
    if (handler.id) {
        identifier = "id: \"".concat(handler.id, "\"");
    }
    else {
        identifier = "topic: ".concat(topic);
    }
    var mutationArguments = {
        MUTATION_NAME: getMutationName(handler, operation),
        IDENTIFIER: identifier,
        MUTATION_PARAMS: '',
    };
    if (operation !== types_2.WebhookOperation.Delete) {
        switch (handler.deliveryMethod) {
            case types_2.DeliveryMethod.Http:
                params.callbackUrl = "\"".concat((0, registry_1.addHostToCallbackUrl)(config, handler.callbackUrl), "\"");
                break;
            case types_2.DeliveryMethod.EventBridge:
                params.arn = "\"".concat(handler.arn, "\"");
                break;
            case types_2.DeliveryMethod.PubSub:
                params.pubSubProject = "\"".concat(handler.pubSubProject, "\"");
                params.pubSubTopic = "\"".concat(handler.pubSubTopic, "\"");
                break;
            default:
                throw new error_1.InvalidDeliveryMethodError("Unrecognized delivery method '".concat(handler.deliveryMethod, "'"));
        }
        if (handler.includeFields) {
            params.includeFields = JSON.stringify(handler.includeFields);
        }
        if (handler.metafieldNamespaces) {
            params.metafieldNamespaces = JSON.stringify(handler.metafieldNamespaces);
        }
        if (handler.deliveryMethod === types_2.DeliveryMethod.Http &&
            handler.privateMetafieldNamespaces) {
            params.privateMetafieldNamespaces = JSON.stringify(handler.privateMetafieldNamespaces);
        }
        var paramsString = Object.entries(params)
            .map(function (_a) {
            var _b = tslib_1.__read(_a, 2), key = _b[0], value = _b[1];
            return "".concat(key, ": ").concat(value);
        })
            .join(', ');
        mutationArguments.MUTATION_PARAMS = "webhookSubscription: {".concat(paramsString, "}");
    }
    return (0, query_template_1.queryTemplate)(exports.TEMPLATE_MUTATION, mutationArguments);
}
function getMutationName(handler, operation) {
    switch (operation) {
        case types_2.WebhookOperation.Create:
            return "".concat(getEndpoint(handler), "Create");
        case types_2.WebhookOperation.Update:
            return "".concat(getEndpoint(handler), "Update");
        case types_2.WebhookOperation.Delete:
            return 'webhookSubscriptionDelete';
        default:
            throw new error_1.ShopifyError("Unrecognized operation '".concat(operation, "'"));
    }
}
function getEndpoint(handler) {
    switch (handler.deliveryMethod) {
        case types_2.DeliveryMethod.Http:
            return 'webhookSubscription';
        case types_2.DeliveryMethod.EventBridge:
            return 'eventBridgeWebhookSubscription';
        case types_2.DeliveryMethod.PubSub:
            return 'pubSubWebhookSubscription';
        default:
            throw new error_1.ShopifyError("Unrecognized delivery method '".concat(handler.deliveryMethod, "'"));
    }
}
function isSuccess(result, handler, operation) {
    var mutationName = getMutationName(handler, operation);
    return Boolean(result.data &&
        result.data[mutationName] &&
        result.data[mutationName].userErrors.length === 0);
}
exports.TEMPLATE_GET_HANDLERS = "{\n  webhookSubscriptions(\n    first: 250,\n    after: {{END_CURSOR}},\n  ) {\n    edges {\n      node {\n        id\n        topic\n        includeFields\n        metafieldNamespaces\n        privateMetafieldNamespaces\n        endpoint {\n          __typename\n          ... on WebhookHttpEndpoint {\n            callbackUrl\n          }\n          ... on WebhookEventBridgeEndpoint {\n            arn\n          }\n          ... on WebhookPubSubEndpoint {\n            pubSubProject\n            pubSubTopic\n          }\n        }\n      }\n    }\n    pageInfo {\n      endCursor\n      hasNextPage\n    }\n  }\n}";
exports.TEMPLATE_MUTATION = "\n  mutation webhookSubscription {\n    {{MUTATION_NAME}}(\n      {{IDENTIFIER}},\n      {{MUTATION_PARAMS}}\n    ) {\n      userErrors {\n        field\n        message\n      }\n    }\n  }\n";
//# sourceMappingURL=register.js.map