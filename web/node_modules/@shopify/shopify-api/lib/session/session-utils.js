"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCurrentSessionId = exports.getOfflineId = exports.getJwtSessionId = void 0;
var tslib_1 = require("tslib");
var types_1 = require("../auth/oauth/types");
var http_1 = require("../../runtime/http");
var shop_validator_1 = require("../utils/shop-validator");
var logger_1 = require("../logger");
var ShopifyErrors = tslib_1.__importStar(require("../error"));
var decode_session_token_1 = require("./decode-session-token");
function getJwtSessionId(config) {
    return function (shop, userId) {
        return "".concat((0, shop_validator_1.sanitizeShop)(config)(shop, true), "_").concat(userId);
    };
}
exports.getJwtSessionId = getJwtSessionId;
function getOfflineId(config) {
    return function (shop) {
        return "offline_".concat((0, shop_validator_1.sanitizeShop)(config)(shop, true));
    };
}
exports.getOfflineId = getOfflineId;
function getCurrentSessionId(config) {
    return function getCurrentSessionId(_a) {
        var isOnline = _a.isOnline, adapterArgs = tslib_1.__rest(_a, ["isOnline"]);
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var request, log, authHeader, matches, jwtPayload, shop, cookies;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, (0, http_1.abstractConvertRequest)(adapterArgs)];
                    case 1:
                        request = _b.sent();
                        log = (0, logger_1.logger)(config);
                        if (!config.isEmbeddedApp) return [3 /*break*/, 5];
                        log.debug('App is embedded, looking for session id in JWT payload', {
                            isOnline: isOnline,
                        });
                        authHeader = request.headers.Authorization;
                        if (!authHeader) return [3 /*break*/, 3];
                        matches = (typeof authHeader === 'string' ? authHeader : authHeader[0]).match(/^Bearer (.+)$/);
                        if (!matches) {
                            log.error('Missing Bearer token in authorization header', { isOnline: isOnline });
                            throw new ShopifyErrors.MissingJwtTokenError('Missing Bearer token in authorization header');
                        }
                        return [4 /*yield*/, (0, decode_session_token_1.decodeSessionToken)(config)(matches[1])];
                    case 2:
                        jwtPayload = _b.sent();
                        shop = jwtPayload.dest.replace(/^https:\/\//, '');
                        log.debug('Found valid JWT payload', { shop: shop, isOnline: isOnline });
                        if (isOnline) {
                            return [2 /*return*/, getJwtSessionId(config)(shop, jwtPayload.sub)];
                        }
                        else {
                            return [2 /*return*/, getOfflineId(config)(shop)];
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        log.error('Missing Authorization header, was the request made with authenticatedFetch?', { isOnline: isOnline });
                        _b.label = 4;
                    case 4: return [3 /*break*/, 6];
                    case 5:
                        log.debug('App is not embedded, looking for session id in cookies', {
                            isOnline: isOnline,
                        });
                        cookies = new http_1.Cookies(request, {}, {
                            keys: [config.apiSecretKey],
                        });
                        return [2 /*return*/, cookies.getAndVerify(types_1.SESSION_COOKIE_NAME)];
                    case 6: return [2 /*return*/, undefined];
                }
            });
        });
    };
}
exports.getCurrentSessionId = getCurrentSessionId;
//# sourceMappingURL=session-utils.js.map