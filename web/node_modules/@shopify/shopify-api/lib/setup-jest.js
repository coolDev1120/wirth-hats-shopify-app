"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var semver_1 = tslib_1.__importDefault(require("semver"));
require("../adapters/mock");
var mock_test_requests_1 = require("../adapters/mock/mock_test_requests");
var http_1 = require("../runtime/http");
var version_1 = require("./version");
beforeEach(function () {
    mock_test_requests_1.mockTestRequests.reset();
});
afterEach(function () {
    var remainingResponses = mock_test_requests_1.mockTestRequests.getResponses();
    if (remainingResponses.length) {
        throw new Error("Test did not check all expected responses, responses: ".concat(JSON.stringify(remainingResponses, undefined, 2)));
    }
});
expect.extend({
    /**
     * Checks if two dates in the form of numbers are within seconds of each other
     *
     * @param received First date
     * @param compareDate Second date
     * @param seconds The number of seconds the first and second date should be within
     */
    toBeWithinSecondsOf: function (received, compareDate, seconds) {
        if (received &&
            compareDate &&
            Math.abs(received - compareDate) <= seconds * 1000) {
            return {
                message: function () {
                    return "expected ".concat(received, " not to be within ").concat(seconds, " seconds of ").concat(compareDate);
                },
                pass: true,
            };
        }
        else {
            return {
                message: function () {
                    return "expected ".concat(received, " to be within ").concat(seconds, " seconds of ").concat(compareDate);
                },
                pass: false,
            };
        }
    },
    toMatchMadeHttpRequest: function (_a) {
        var method = _a.method, domain = _a.domain, path = _a.path, _b = _a.query, query = _b === void 0 ? '' : _b, _c = _a.headers, headers = _c === void 0 ? {} : _c, _d = _a.data, data = _d === void 0 ? undefined : _d, _e = _a.attempts, attempts = _e === void 0 ? 1 : _e;
        var searchHeaders = (0, http_1.canonicalizeHeaders)(headers);
        var searchUrl = new URL("https://".concat(domain).concat(path).concat(query ? "?".concat(query) : ''));
        // We compare the sorted query items, so we can expect arguments in a different order
        var searchQueryItems = Array.from(searchUrl.searchParams.entries()).sort();
        var cleanSearchUrl = searchUrl.toString().split('?')[0];
        for (var i = 0; i < attempts; i++) {
            var matchingRequest = mock_test_requests_1.mockTestRequests.getRequest();
            if (!matchingRequest) {
                throw new Error("No request was made, but expected ".concat(JSON.stringify({ method: method, domain: domain, path: path }, undefined, 2)));
            }
            var requestUrl = new URL(matchingRequest.url);
            var requestQueryItems = Array.from(requestUrl.searchParams.entries()).sort();
            var cleanRequestUrl = requestUrl.toString().split('?')[0];
            expect(matchingRequest).not.toBeNull();
            expect(matchingRequest.method).toEqual(method);
            expect(matchingRequest.headers).toMatchObject(searchHeaders);
            expect(cleanRequestUrl).toEqual(cleanSearchUrl);
            expect(requestQueryItems).toEqual(searchQueryItems);
            if (data) {
                if (typeof data === 'string' ||
                    data.constructor.name === 'StringContaining') {
                    expect(matchingRequest.body).toEqual(data);
                }
                else {
                    var requestBody = typeof matchingRequest.body === 'string'
                        ? JSON.parse(matchingRequest.body)
                        : matchingRequest.body;
                    expect(requestBody).toMatchObject(data);
                }
            }
            else {
                expect(matchingRequest.body).toBeFalsy();
            }
        }
        return {
            message: function () { return "expected to have seen the right HTTP requests"; },
            pass: true,
        };
    },
    toBeWithinDeprecationSchedule: function (version) {
        return {
            message: function () {
                return "Found deprecation limited to version ".concat(version, ", please update or remove it.");
            },
            pass: semver_1.default.lt(version_1.SHOPIFY_API_LIBRARY_VERSION, version),
        };
    },
});
//# sourceMappingURL=setup-jest.js.map