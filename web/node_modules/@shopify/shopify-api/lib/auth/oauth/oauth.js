"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.callback = exports.begin = void 0;
var tslib_1 = require("tslib");
var uuid_1 = require("uuid");
var processed_query_1 = tslib_1.__importDefault(require("../../utils/processed-query"));
var ShopifyErrors = tslib_1.__importStar(require("../../error"));
var hmac_validator_1 = require("../../utils/hmac-validator");
var shop_validator_1 = require("../../utils/shop-validator");
var session_1 = require("../../session/session");
var session_utils_1 = require("../../session/session-utils");
var http_client_1 = require("../../clients/http_client/http_client");
var types_1 = require("../../clients/http_client/types");
var http_1 = require("../../../runtime/http");
var logger_1 = require("../../logger");
var types_2 = require("./types");
var nonce_1 = require("./nonce");
var safe_compare_1 = require("./safe-compare");
function begin(config) {
    var _this = this;
    return function (_a) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var log, cleanShop, request, response, cookies, state, query, processedQuery, redirectUrl;
        var shop = _a.shop, callbackPath = _a.callbackPath, isOnline = _a.isOnline, adapterArgs = tslib_1.__rest(_a, ["shop", "callbackPath", "isOnline"]);
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    throwIfPrivateApp(config.isPrivateApp, 'Cannot perform OAuth for private apps');
                    log = (0, logger_1.logger)(config);
                    log.info('Beginning OAuth', { shop: shop, isOnline: isOnline, callbackPath: callbackPath });
                    cleanShop = (0, shop_validator_1.sanitizeShop)(config)(shop, true);
                    return [4 /*yield*/, (0, http_1.abstractConvertRequest)(adapterArgs)];
                case 1:
                    request = _b.sent();
                    return [4 /*yield*/, (0, http_1.abstractConvertIncomingResponse)(adapterArgs)];
                case 2:
                    response = _b.sent();
                    cookies = new http_1.Cookies(request, response, {
                        keys: [config.apiSecretKey],
                        secure: true,
                    });
                    state = (0, nonce_1.nonce)();
                    return [4 /*yield*/, cookies.setAndSign(types_2.STATE_COOKIE_NAME, state, {
                            expires: new Date(Date.now() + 60000),
                            sameSite: 'lax',
                            secure: true,
                            path: callbackPath,
                        })];
                case 3:
                    _b.sent();
                    query = {
                        client_id: config.apiKey,
                        scope: config.scopes.toString(),
                        redirect_uri: "".concat(config.hostScheme, "://").concat(config.hostName).concat(callbackPath),
                        state: state,
                        'grant_options[]': isOnline ? 'per-user' : '',
                    };
                    processedQuery = new processed_query_1.default();
                    processedQuery.putAll(query);
                    redirectUrl = "https://".concat(cleanShop, "/admin/oauth/authorize").concat(processedQuery.stringify());
                    response.statusCode = 302;
                    response.statusText = 'Found';
                    response.headers = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, response.headers), cookies.response.headers), { Location: redirectUrl });
                    log.debug("OAuth started, redirecting to ".concat(redirectUrl), { shop: shop, isOnline: isOnline });
                    return [2 /*return*/, (0, http_1.abstractConvertResponse)(response, adapterArgs)];
            }
        });
    }); };
}
exports.begin = begin;
function callback(config) {
    return function callback(_a) {
        var isOnlineParam = _a.isOnline, adapterArgs = tslib_1.__rest(_a, ["isOnline"]);
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var log, request, query, shop, cookies, stateFromCookie, authQuery, body, postParams, cleanShop, HttpClient, client, postResponse, session;
            var _b;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        throwIfPrivateApp(config.isPrivateApp, 'Cannot perform OAuth for private apps');
                        log = (0, logger_1.logger)(config);
                        if (!(isOnlineParam !== undefined)) return [3 /*break*/, 2];
                        return [4 /*yield*/, log.deprecated('7.0.0', 'The isOnline param is no longer required for auth callback')];
                    case 1:
                        _c.sent();
                        _c.label = 2;
                    case 2: return [4 /*yield*/, (0, http_1.abstractConvertRequest)(adapterArgs)];
                    case 3:
                        request = _c.sent();
                        query = new URL(request.url, "".concat(config.hostScheme, "://").concat(config.hostName)).searchParams;
                        shop = query.get('shop');
                        log.info('Completing OAuth', { shop: shop });
                        cookies = new http_1.Cookies(request, {}, {
                            keys: [config.apiSecretKey],
                            secure: true,
                        });
                        return [4 /*yield*/, cookies.getAndVerify(types_2.STATE_COOKIE_NAME)];
                    case 4:
                        stateFromCookie = _c.sent();
                        cookies.deleteCookie(types_2.STATE_COOKIE_NAME);
                        if (!stateFromCookie) {
                            log.error('Could not find OAuth cookie', { shop: shop });
                            throw new ShopifyErrors.CookieNotFound("Cannot complete OAuth process. Could not find an OAuth cookie for shop url: ".concat(shop));
                        }
                        authQuery = Object.fromEntries(query.entries());
                        return [4 /*yield*/, validQuery({ config: config, query: authQuery, stateFromCookie: stateFromCookie })];
                    case 5:
                        if (!(_c.sent())) {
                            log.error('Invalid OAuth callback', { shop: shop, stateFromCookie: stateFromCookie });
                            throw new ShopifyErrors.InvalidOAuthError('Invalid OAuth callback.');
                        }
                        log.debug('OAuth request is valid, requesting access token', { shop: shop });
                        body = {
                            client_id: config.apiKey,
                            client_secret: config.apiSecretKey,
                            code: query.get('code'),
                        };
                        postParams = {
                            path: '/admin/oauth/access_token',
                            type: types_1.DataType.JSON,
                            data: body,
                        };
                        cleanShop = (0, shop_validator_1.sanitizeShop)(config)(query.get('shop'), true);
                        HttpClient = (0, http_client_1.httpClientClass)(config);
                        client = new HttpClient({ domain: cleanShop });
                        return [4 /*yield*/, client.post(postParams)];
                    case 6:
                        postResponse = _c.sent();
                        session = createSession({
                            postResponse: postResponse,
                            shop: cleanShop,
                            stateFromCookie: stateFromCookie,
                            config: config,
                        });
                        if (!!config.isEmbeddedApp) return [3 /*break*/, 8];
                        return [4 /*yield*/, cookies.setAndSign(types_2.SESSION_COOKIE_NAME, session.id, {
                                expires: session.expires,
                                sameSite: 'lax',
                                secure: true,
                                path: '/',
                            })];
                    case 7:
                        _c.sent();
                        _c.label = 8;
                    case 8:
                        _b = {};
                        return [4 /*yield*/, (0, http_1.abstractConvertHeaders)(cookies.response.headers, adapterArgs)];
                    case 9: return [2 /*return*/, (_b.headers = (_c.sent()),
                            _b.session = session,
                            _b)];
                }
            });
        });
    };
}
exports.callback = callback;
function validQuery(_a) {
    var config = _a.config, query = _a.query, stateFromCookie = _a.stateFromCookie;
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, (0, hmac_validator_1.validateHmac)(config)(query)];
                case 1: return [2 /*return*/, ((_b.sent()) &&
                        (0, safe_compare_1.safeCompare)(query.state, stateFromCookie))];
            }
        });
    });
}
function createSession(_a) {
    var config = _a.config, postResponse = _a.postResponse, shop = _a.shop, stateFromCookie = _a.stateFromCookie;
    var associatedUser = postResponse.body
        .associated_user;
    var isOnline = Boolean(associatedUser);
    (0, logger_1.logger)(config).info('Creating new session', { shop: shop, isOnline: isOnline });
    if (isOnline) {
        var sessionId = void 0;
        var responseBody = postResponse.body;
        var access_token = responseBody.access_token, scope = responseBody.scope, rest = tslib_1.__rest(responseBody, ["access_token", "scope"]);
        var sessionExpiration = new Date(Date.now() + responseBody.expires_in * 1000);
        if (config.isEmbeddedApp) {
            sessionId = (0, session_utils_1.getJwtSessionId)(config)(shop, "".concat(rest.associated_user.id));
        }
        else {
            sessionId = (0, uuid_1.v4)();
        }
        return new session_1.Session({
            id: sessionId,
            shop: shop,
            state: stateFromCookie,
            isOnline: isOnline,
            accessToken: access_token,
            scope: scope,
            expires: sessionExpiration,
            onlineAccessInfo: rest,
        });
    }
    else {
        var responseBody = postResponse.body;
        return new session_1.Session({
            id: (0, session_utils_1.getOfflineId)(config)(shop),
            shop: shop,
            state: stateFromCookie,
            isOnline: isOnline,
            accessToken: responseBody.access_token,
            scope: responseBody.scope,
        });
    }
}
function throwIfPrivateApp(isPrivateApp, message) {
    if (isPrivateApp) {
        throw new ShopifyErrors.PrivateAppError(message);
    }
}
//# sourceMappingURL=oauth.js.map