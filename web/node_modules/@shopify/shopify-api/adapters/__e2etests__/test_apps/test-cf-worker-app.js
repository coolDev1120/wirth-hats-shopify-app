"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
require("../../cf-worker");
var http_client_1 = require("../../../lib/clients/http_client/http_client");
var utils_1 = require("../utils");
/* Codes for different Colours */
var RED = '\x1b[31m';
var GREEN = '\x1b[32m';
var RESET = '\x1b[39m';
var HttpClient = (0, http_client_1.httpClientClass)(utils_1.config, 'http');
var defaultRetryTimer = HttpClient.RETRY_WAIT_TIME;
var testCount = 0;
function params(testRequest) {
    return {
        path: testRequest.url,
        type: testRequest.bodyType,
        data: JSON.stringify(testRequest.body),
    };
}
function setRestClientRetryTime(time) {
    // We de-type HttpClient here so we can alter its readonly time property
    HttpClient.RETRY_WAIT_TIME = time;
}
/* eslint-disable-next-line import/no-anonymous-default-export */
exports.default = {
    fetch: function (req, _env, _ctx) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var apiServerPort, client, testConfig, testRequest, expectedResponse, tries, testPassed, timedOut_1, retryTimeout, testFailedDebug_1, response, _a, error_1;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        apiServerPort = parseInt(globalThis.HTTP_SERVER_PORT || '3000', 10);
                        client = new HttpClient({
                            domain: "localhost:".concat(apiServerPort),
                        });
                        if (!(req.method === 'POST')) return [3 /*break*/, 14];
                        return [4 /*yield*/, req.json()];
                    case 1:
                        testConfig = _b.sent();
                        testRequest = testConfig.testRequest;
                        expectedResponse = testConfig.expectedResponse;
                        tries = testRequest.tries || 1;
                        testPassed = false;
                        timedOut_1 = false;
                        retryTimeout = void 0;
                        testFailedDebug_1 = '';
                        response = void 0;
                        setRestClientRetryTime(defaultRetryTimer);
                        testCount++;
                        console.log("[cfWorker] testRequest #".concat(testCount, " = ").concat(JSON.stringify(testRequest, undefined, 2), "\n"));
                        if (typeof testRequest.retryTimeoutTimer !== 'undefined') {
                            setRestClientRetryTime(testRequest.retryTimeoutTimer);
                            console.log("[cfWorker] RETRY_TIME_WAIT (BEFORE) = ".concat(HttpClient.RETRY_WAIT_TIME, "\n"));
                            if (testRequest.retryTimeoutTimer !== 0) {
                                console.log("[cfWorker] setting setTimeout @ ".concat(HttpClient.RETRY_WAIT_TIME, " ms\n"));
                                retryTimeout = setTimeout(function () {
                                    try {
                                        throw new Error('Request was not retried within the interval defined by Retry-After, test failed');
                                    }
                                    catch (error) {
                                        console.log("[cfWorker] ".concat(RED, "setTimeout fired!").concat(RESET, " @ ").concat(HttpClient.RETRY_WAIT_TIME, "\n"));
                                        testFailedDebug_1 = JSON.stringify({
                                            errorMessageReceived: error.message,
                                        });
                                        timedOut_1 = true;
                                    }
                                }, testRequest.retryTimeoutTimer);
                            }
                        }
                        _a = testRequest.method.toLowerCase();
                        switch (_a) {
                            case 'get': return [3 /*break*/, 2];
                            case 'post': return [3 /*break*/, 6];
                            case 'put': return [3 /*break*/, 8];
                            case 'delete': return [3 /*break*/, 10];
                        }
                        return [3 /*break*/, 12];
                    case 2:
                        _b.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, client.get({
                                path: testRequest.url,
                                tries: tries,
                                extraHeaders: testRequest.headers,
                            })];
                    case 3:
                        response = _b.sent();
                        if (timedOut_1) {
                            console.log("[cfWorker] timedOut=".concat(timedOut_1, ", testPassed=").concat(testPassed, ", testFailedDebug=").concat(testFailedDebug_1, "\n"));
                        }
                        else {
                            testPassed =
                                (0, utils_1.matchHeaders)(response.headers, expectedResponse.headers) && JSON.stringify(response.body) === expectedResponse.body;
                            testFailedDebug_1 = JSON.stringify({
                                bodyExpected: expectedResponse.body,
                                bodyReceived: response.body,
                                headersExpected: expectedResponse.headers,
                                headersReceived: response.headers,
                            });
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        error_1 = _b.sent();
                        testPassed = error_1.constructor.name.startsWith(expectedResponse.errorType);
                        if (expectedResponse.errorType === 'HttpResponseError') {
                            testPassed =
                                testPassed &&
                                    'response' in error_1 &&
                                    'code' in error_1.response &&
                                    error_1.response.code === expectedResponse.statusCode &&
                                    'statusText' in error_1.response &&
                                    error_1.response.statusText === expectedResponse.statusText;
                        }
                        if ('expectRequestId' in expectedResponse) {
                            testPassed =
                                testPassed &&
                                    error_1.message.includes(expectedResponse.expectRequestId);
                        }
                        if ('errorMessage' in expectedResponse) {
                            testPassed =
                                testPassed && error_1.message === expectedResponse.errorMessage;
                        }
                        testFailedDebug_1 = JSON.stringify({
                            statusCodeExpected: expectedResponse.statusCode,
                            statusCodeReceived: error_1.code,
                            statusTextExpected: expectedResponse.statusText,
                            statusTextReceived: error_1.statusText,
                            errorTypeExpected: expectedResponse.errorType,
                            errorTypeReceived: error_1.constructor.name,
                            errorMessageExpected: expectedResponse.errorMessage,
                            errorMessageReceived: error_1.message,
                        });
                        return [3 /*break*/, 5];
                    case 5: return [3 /*break*/, 13];
                    case 6: return [4 /*yield*/, client.post(params(testRequest))];
                    case 7:
                        response = _b.sent();
                        testPassed = JSON.stringify(response.body) === expectedResponse.body;
                        return [3 /*break*/, 13];
                    case 8: return [4 /*yield*/, client.put(params(testRequest))];
                    case 9:
                        response = _b.sent();
                        testPassed = JSON.stringify(response.body) === expectedResponse.body;
                        return [3 /*break*/, 13];
                    case 10: return [4 /*yield*/, client.delete({ path: testRequest.url })];
                    case 11:
                        response = _b.sent();
                        testPassed = JSON.stringify(response.body) === expectedResponse.body;
                        return [3 /*break*/, 13];
                    case 12:
                        testPassed = false;
                        _b.label = 13;
                    case 13:
                        if (typeof testRequest.retryTimeoutTimer !== 'undefined' &&
                            testRequest.retryTimeoutTimer !== 0 &&
                            typeof retryTimeout !== 'undefined') {
                            clearTimeout(retryTimeout);
                        }
                        console.log("[cfWorker] test #".concat(testCount, " passed=").concat(testPassed ? GREEN : RED).concat(testPassed).concat(RESET, ", debug=").concat(JSON.stringify(testFailedDebug_1, undefined, 2), "\n"));
                        if (testPassed) {
                            return [2 /*return*/, new Response('Test passed!', { status: 200 })];
                        }
                        else {
                            return [2 /*return*/, new Response(testFailedDebug_1, {
                                    status: 500,
                                    headers: {
                                        'Content-Type': 'application/json',
                                    },
                                })];
                        }
                        return [3 /*break*/, 15];
                    case 14: return [2 /*return*/, new Response('Ready!', { status: 200 })];
                    case 15: return [2 /*return*/];
                }
            });
        });
    },
};
//# sourceMappingURL=test-cf-worker-app.js.map