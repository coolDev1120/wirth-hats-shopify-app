"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var http_1 = require("http");
require("../../node");
var http_client_1 = require("../../../lib/clients/http_client/http_client");
var utils_1 = require("../utils");
/* Codes for different Colours */
var RED = '\x1b[31m';
var GREEN = '\x1b[32m';
var RESET = '\x1b[39m';
var HttpClient = (0, http_client_1.httpClientClass)(utils_1.config, 'http');
/* eslint-disable no-process-env */
var apiServerPort = parseInt(process.env.HTTP_SERVER_PORT || '3000', 10);
var appPort = parseInt(process.env.PORT || '8787', 10);
/* eslint-enable no-process-env */
var apiServer = "localhost:".concat(apiServerPort);
var client = new HttpClient({ domain: apiServer });
var defaultRetryTimer = HttpClient.RETRY_WAIT_TIME;
var testCount = 0;
var server = (0, http_1.createServer)(function (request, appResponse) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var testConfig, testRequest, expectedResponse, tries, params, testPassed, timedOut_1, testFailedDebug_1, response, retryTimeout, _a, error_1;
    return tslib_1.__generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                if (!(request.method === 'POST')) return [3 /*break*/, 14];
                return [4 /*yield*/, getJSONDataFromRequestStream(request)];
            case 1:
                testConfig = _b.sent();
                testRequest = testConfig.testRequest;
                expectedResponse = testConfig.expectedResponse;
                tries = testRequest.tries || 1;
                params = {
                    path: testRequest.url,
                    type: testRequest.bodyType,
                    data: JSON.stringify(testRequest.body),
                };
                testPassed = false;
                timedOut_1 = false;
                testFailedDebug_1 = '';
                response = void 0;
                retryTimeout = void 0;
                setRestClientRetryTime(defaultRetryTimer);
                testCount++;
                console.log("[node] testRequest #".concat(testCount, " = ").concat(JSON.stringify(testRequest, undefined, 2), "\n"));
                if (typeof testRequest.retryTimeoutTimer !== 'undefined') {
                    setRestClientRetryTime(testRequest.retryTimeoutTimer);
                    console.log("[node] RETRY_TIME_WAIT (BEFORE) = ".concat(HttpClient.RETRY_WAIT_TIME, " ms\n\n"));
                    if (testRequest.retryTimeoutTimer !== 0) {
                        console.log("[node] setting setTimeout @ ".concat(HttpClient.RETRY_WAIT_TIME, " ms\n"));
                        retryTimeout = setTimeout(function () {
                            try {
                                throw new Error('Request was not retried within the interval defined by Retry-After, test failed');
                            }
                            catch (error) {
                                console.log("[node] ".concat(RED, "setTimeout fired!").concat(RESET, " @ ").concat(HttpClient.RETRY_WAIT_TIME, "\n"));
                                testFailedDebug_1 = JSON.stringify({
                                    errorMessageReceived: error.message,
                                });
                                timedOut_1 = true;
                            }
                        }, testRequest.retryTimeoutTimer);
                    }
                }
                _a = testRequest.method.toLowerCase();
                switch (_a) {
                    case 'get': return [3 /*break*/, 2];
                    case 'post': return [3 /*break*/, 6];
                    case 'put': return [3 /*break*/, 8];
                    case 'delete': return [3 /*break*/, 10];
                }
                return [3 /*break*/, 12];
            case 2:
                _b.trys.push([2, 4, , 5]);
                return [4 /*yield*/, client.get({
                        path: testRequest.url,
                        tries: tries,
                        extraHeaders: testRequest.headers,
                    })];
            case 3:
                response = _b.sent();
                if (timedOut_1) {
                    console.log("[node] timedOut=".concat(timedOut_1, ", testPassed=").concat(testPassed, ", testFailedDebug=").concat(testFailedDebug_1, "\n"));
                }
                else {
                    testPassed =
                        (0, utils_1.matchHeaders)(response.headers, expectedResponse.headers) && JSON.stringify(response.body) === expectedResponse.body;
                    testFailedDebug_1 = JSON.stringify({
                        bodyExpected: expectedResponse.body,
                        bodyReceived: response.body,
                        headersExpected: expectedResponse.headers,
                        headersReceived: response.headers,
                    });
                }
                return [3 /*break*/, 5];
            case 4:
                error_1 = _b.sent();
                testPassed = error_1.constructor.name.startsWith(expectedResponse.errorType);
                if (expectedResponse.errorType === 'HttpResponseError') {
                    testPassed =
                        testPassed &&
                            'response' in error_1 &&
                            'code' in error_1.response &&
                            error_1.response.code === expectedResponse.statusCode &&
                            'statusText' in error_1.response &&
                            error_1.response.statusText === expectedResponse.statusText;
                }
                if ('expectRequestId' in expectedResponse) {
                    testPassed =
                        testPassed &&
                            error_1.message.includes(expectedResponse.expectRequestId);
                }
                if ('errorMessage' in expectedResponse) {
                    testPassed =
                        testPassed && error_1.message === expectedResponse.errorMessage;
                }
                testFailedDebug_1 = JSON.stringify({
                    statusCodeExpected: expectedResponse.statusCode,
                    statusCodeReceived: error_1.code,
                    statusTextExpected: expectedResponse.statusText,
                    statusTextReceived: error_1.statusText,
                    errorTypeExpected: expectedResponse.errorType,
                    errorTypeReceived: error_1.constructor.name,
                    errorMessageExpected: expectedResponse.errorMessage,
                    errorMessageReceived: error_1.message,
                });
                return [3 /*break*/, 5];
            case 5: return [3 /*break*/, 13];
            case 6: return [4 /*yield*/, client.post(params)];
            case 7:
                response = _b.sent();
                testPassed = JSON.stringify(response.body) === expectedResponse.body;
                return [3 /*break*/, 13];
            case 8: return [4 /*yield*/, client.put(params)];
            case 9:
                response = _b.sent();
                testPassed = JSON.stringify(response.body) === expectedResponse.body;
                return [3 /*break*/, 13];
            case 10: return [4 /*yield*/, client.delete({ path: testRequest.url })];
            case 11:
                response = _b.sent();
                testPassed = JSON.stringify(response.body) === expectedResponse.body;
                return [3 /*break*/, 13];
            case 12:
                testPassed = false;
                _b.label = 13;
            case 13:
                if (typeof testRequest.retryTimeoutTimer !== 'undefined' &&
                    testRequest.retryTimeoutTimer !== 0 &&
                    typeof retryTimeout !== 'undefined') {
                    clearTimeout(retryTimeout);
                }
                console.log("[node] test #".concat(testCount, " passed=").concat(testPassed ? GREEN : RED).concat(testPassed).concat(RESET, ", debug=").concat(JSON.stringify(testFailedDebug_1, undefined, 2), "\n"));
                if (testPassed) {
                    appResponse.statusCode = 200;
                    appResponse.end('Test passed!');
                }
                else {
                    appResponse.statusCode = 500;
                    appResponse.setHeader('Content-Type', 'application/json');
                    appResponse.end(testFailedDebug_1);
                }
                return [3 /*break*/, 15];
            case 14:
                appResponse.statusCode = 200;
                appResponse.end('Ready!');
                _b.label = 15;
            case 15: return [2 /*return*/];
        }
    });
}); });
function getJSONDataFromRequestStream(request) {
    return new Promise(function (resolve) {
        var chunks = [];
        request.on('data', function (chunk) {
            chunks.push(chunk);
        });
        request.on('end', function () {
            resolve(JSON.parse(Buffer.concat(chunks).toString()));
        });
    });
}
function handle(_signal) {
    process.exit(0);
}
function setRestClientRetryTime(time) {
    // We de-type HttpClient here so we can alter its readonly time property
    HttpClient.RETRY_WAIT_TIME = time;
}
process.on('SIGINT', handle);
process.on('SIGTERM', handle);
server.listen(appPort, function () {
    console.log("Listening on :".concat(appPort));
});
//# sourceMappingURL=test-node-app.js.map