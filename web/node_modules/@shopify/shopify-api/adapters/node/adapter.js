"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nodeRuntimeString = exports.nodeFetch = exports.nodeConvertAndSetHeaders = exports.nodeConvertAndSendResponse = exports.nodeConvertIncomingResponse = exports.nodeConvertRequest = void 0;
var tslib_1 = require("tslib");
var node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
var http_1 = require("../../runtime/http");
function nodeConvertRequest(adapterArgs) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var req;
        return tslib_1.__generator(this, function (_b) {
            req = adapterArgs.rawRequest;
            return [2 /*return*/, {
                    headers: (0, http_1.canonicalizeHeaders)(tslib_1.__assign({}, req.headers)),
                    method: (_a = req.method) !== null && _a !== void 0 ? _a : 'GET',
                    // Express.js overrides the url property, so we want to use originalUrl for it
                    url: req.originalUrl || req.url,
                }];
        });
    });
}
exports.nodeConvertRequest = nodeConvertRequest;
function nodeConvertIncomingResponse(adapterArgs) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            return [2 /*return*/, {
                    statusCode: adapterArgs.rawResponse.statusCode,
                    statusText: adapterArgs.rawResponse.statusMessage,
                    headers: (0, http_1.canonicalizeHeaders)(adapterArgs.rawResponse.getHeaders()),
                }];
        });
    });
}
exports.nodeConvertIncomingResponse = nodeConvertIncomingResponse;
function nodeConvertAndSendResponse(response, adapterArgs) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var res;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    res = adapterArgs.rawResponse;
                    if (!response.headers) return [3 /*break*/, 2];
                    return [4 /*yield*/, nodeConvertAndSetHeaders(response.headers, adapterArgs)];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2:
                    if (response.body) {
                        res.write(response.body);
                    }
                    res.statusCode = response.statusCode;
                    res.statusMessage = response.statusText;
                    res.end();
                    return [2 /*return*/];
            }
        });
    });
}
exports.nodeConvertAndSendResponse = nodeConvertAndSendResponse;
function nodeConvertAndSetHeaders(headers, adapterArgs) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var res;
        return tslib_1.__generator(this, function (_a) {
            res = adapterArgs.rawResponse;
            Object.entries(headers).forEach(function (_a) {
                var _b = tslib_1.__read(_a, 2), header = _b[0], value = _b[1];
                return res.setHeader(header, value);
            });
            return [2 /*return*/];
        });
    });
}
exports.nodeConvertAndSetHeaders = nodeConvertAndSetHeaders;
function nodeFetch(_a) {
    var url = _a.url, method = _a.method, _b = _a.headers, headers = _b === void 0 ? {} : _b, body = _a.body;
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var resp, respBody;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4 /*yield*/, (0, node_fetch_1.default)(url, { method: method, headers: (0, http_1.flatHeaders)(headers), body: body })];
                case 1:
                    resp = _c.sent();
                    return [4 /*yield*/, resp.text()];
                case 2:
                    respBody = _c.sent();
                    return [2 /*return*/, {
                            statusCode: resp.status,
                            statusText: resp.statusText,
                            body: respBody,
                            headers: (0, http_1.canonicalizeHeaders)(Object.fromEntries(resp.headers.entries())),
                        }];
            }
        });
    });
}
exports.nodeFetch = nodeFetch;
function nodeRuntimeString() {
    return "Node ".concat(process.version);
}
exports.nodeRuntimeString = nodeRuntimeString;
//# sourceMappingURL=adapter.js.map