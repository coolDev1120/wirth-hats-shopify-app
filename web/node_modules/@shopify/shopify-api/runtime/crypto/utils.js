"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashString = exports.asBase64 = exports.asHex = exports.createSHA256HMAC = void 0;
var tslib_1 = require("tslib");
var error_1 = require("../../lib/error");
var crypto_1 = require("./crypto");
var types_1 = require("./types");
function createSHA256HMAC(secret, payload, returnFormat) {
    if (returnFormat === void 0) { returnFormat = types_1.HashFormat.Base64; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var cryptoLib, enc, key, signature;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    cryptoLib = typeof (crypto_1.crypto === null || crypto_1.crypto === void 0 ? void 0 : crypto_1.crypto.webcrypto) === 'undefined'
                        ? crypto_1.crypto
                        : crypto_1.crypto.webcrypto;
                    if (!(cryptoLib === null || cryptoLib === void 0 ? void 0 : cryptoLib.subtle)) return [3 /*break*/, 3];
                    enc = new TextEncoder();
                    return [4 /*yield*/, cryptoLib.subtle.importKey('raw', enc.encode(secret), {
                            name: 'HMAC',
                            hash: { name: 'SHA-256' },
                        }, false, ['sign'])];
                case 1:
                    key = _a.sent();
                    return [4 /*yield*/, cryptoLib.subtle.sign('HMAC', key, enc.encode(payload))];
                case 2:
                    signature = _a.sent();
                    return [2 /*return*/, returnFormat === types_1.HashFormat.Base64
                            ? asBase64(signature)
                            : asHex(signature)];
                case 3: return [2 /*return*/, cryptoLib
                        .createHmac('sha256', secret)
                        .update(payload)
                        .digest(returnFormat)];
            }
        });
    });
}
exports.createSHA256HMAC = createSHA256HMAC;
function asHex(buffer) {
    return tslib_1.__spreadArray([], tslib_1.__read(new Uint8Array(buffer)), false).map(function (byte) { return byte.toString(16).padStart(2, '0'); })
        .join('');
}
exports.asHex = asHex;
var LookupTable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
function asBase64(buffer) {
    var output = '';
    var input = new Uint8Array(buffer);
    for (var i = 0; i < input.length;) {
        var byte1 = input[i++];
        var byte2 = input[i++];
        var byte3 = input[i++];
        var enc1 = byte1 >> 2;
        var enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
        var enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
        var enc4 = byte3 & 63;
        if (isNaN(byte2)) {
            enc3 = 64;
        }
        if (isNaN(byte3)) {
            enc4 = 64;
        }
        output +=
            LookupTable[enc1] +
                LookupTable[enc2] +
                LookupTable[enc3] +
                LookupTable[enc4];
    }
    return output;
}
exports.asBase64 = asBase64;
function hashString(str, returnFormat) {
    var buffer = new TextEncoder().encode(str);
    switch (returnFormat) {
        case types_1.HashFormat.Base64:
            return asBase64(buffer);
        case types_1.HashFormat.Hex:
            return asHex(buffer);
        default:
            throw new error_1.ShopifyError("Unrecognized hash format '".concat(returnFormat, "'"));
    }
}
exports.hashString = hashString;
//# sourceMappingURL=utils.js.map