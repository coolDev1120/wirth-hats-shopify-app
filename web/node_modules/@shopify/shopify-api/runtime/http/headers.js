"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flatHeaders = exports.removeHeader = exports.canonicalizeHeaders = exports.addHeader = exports.setHeader = exports.getHeader = exports.getHeaders = exports.canonicalizeHeaderName = void 0;
var tslib_1 = require("tslib");
function canonicalizeHeaderName(hdr) {
    return hdr.replace(/(^|-)(\w+)/g, function (_fullMatch, start, letters) {
        return start +
            letters.slice(0, 1).toUpperCase() +
            letters.slice(1).toLowerCase();
    });
}
exports.canonicalizeHeaderName = canonicalizeHeaderName;
function getHeaders(headers, needle_) {
    var e_1, _a;
    var result = [];
    if (!headers)
        return result;
    var needle = canonicalizeHeaderName(needle_);
    try {
        for (var _b = tslib_1.__values(Object.entries(headers)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = tslib_1.__read(_c.value, 2), key = _d[0], values = _d[1];
            if (canonicalizeHeaderName(key) !== needle)
                continue;
            if (Array.isArray(values)) {
                result.push.apply(result, tslib_1.__spreadArray([], tslib_1.__read(values), false));
            }
            else {
                result.push(values);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return result;
}
exports.getHeaders = getHeaders;
function getHeader(headers, needle) {
    var _a;
    if (!headers)
        return undefined;
    return (_a = getHeaders(headers, needle)) === null || _a === void 0 ? void 0 : _a[0];
}
exports.getHeader = getHeader;
function setHeader(headers, key, value) {
    canonicalizeHeaders(headers);
    headers[canonicalizeHeaderName(key)] = [value];
}
exports.setHeader = setHeader;
function addHeader(headers, key, value) {
    canonicalizeHeaders(headers);
    var canonKey = canonicalizeHeaderName(key);
    var list = headers[canonKey];
    if (!list) {
        list = [];
    }
    else if (!Array.isArray(list)) {
        list = [list];
    }
    headers[canonKey] = list;
    list.push(value);
}
exports.addHeader = addHeader;
function canonicalizeValue(value) {
    if (typeof value === 'number')
        return value.toString();
    return value;
}
function canonicalizeHeaders(hdr) {
    var e_2, _a, _b;
    try {
        for (var _c = tslib_1.__values(Object.entries(hdr)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var _e = tslib_1.__read(_d.value, 2), key = _e[0], values = _e[1];
            var canonKey = canonicalizeHeaderName(key);
            if (!hdr[canonKey])
                hdr[canonKey] = [];
            if (!Array.isArray(hdr[canonKey]))
                hdr[canonKey] = [canonicalizeValue(hdr[canonKey])];
            if (key === canonKey)
                continue;
            delete hdr[key];
            (_b = hdr[canonKey]).push.apply(_b, tslib_1.__spreadArray([], tslib_1.__read([values].flat().map(function (value) { return canonicalizeValue(value); })), false));
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return hdr;
}
exports.canonicalizeHeaders = canonicalizeHeaders;
function removeHeader(headers, needle) {
    canonicalizeHeaders(headers);
    var canonKey = canonicalizeHeaderName(needle);
    delete headers[canonKey];
}
exports.removeHeader = removeHeader;
/*
  Turns a Headers object into a array of tuples, as expected by web standards to
    handle headers that can be specified multiple times.
  [
    ["Set-Cookie", "a=b"],
    ["Set-Cookie", "x=y"],
    // ...
  ]
*/
function flatHeaders(headers) {
    return Object.entries(headers).flatMap(function (_a) {
        var _b = tslib_1.__read(_a, 2), header = _b[0], values = _b[1];
        return Array.isArray(values)
            ? values.map(function (value) { return [header, value]; })
            : [[header, values]];
    });
}
exports.flatHeaders = flatHeaders;
//# sourceMappingURL=headers.js.map